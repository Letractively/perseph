/* Nothing actually usess the charset yet, the db variable in PHP must be set to do the conversion correctly */
default charset "UTF-8";

/* Custom types allow finer control over formatting and conversions. Custom types can
	not be used in the "provider" sections. */
type CustomID<Integer> { 	/* The base type says how this type behaves (for forms,listings,+elsewhere) */

}

/* In this example all of our tables are in actually in one database, but we treat it as two
	DBs for testing. */
provider DBTest {
	/* These first two lines are PHP specific, but as we have only one emitter so far
		we haven't thought about how to extract this part appropriately */
	var db_test;
	type DBSource;
	
	/* This says our definition is extending one in another schema file, in this case one generated by dump_provider.php */
	definition extend;
}

provider DBTest2 {
	func dbtest2_get;
	type DBSource;
	tablePrefixVar dbtest2_prefix;
	
	table names {
		Name<String>;
		ID<Integer>;
	}
}

entity DBSTest {
	fields {
		ID<CustomID> 
			ALT_RECORD_KEY;
		Name<String> 
			ALT_RECORD_KEY TITLE MAXLEN(50)
			LABEL("Logical Name")
			DESC("A description which can be used for forms or for general reference.")
			ALLOW_NULL;
		Date<Date>;
		Time<Time>;
		DateTime<DateTime> ALLOW_NULL;
		Bool<Bool> DEFAULT(True);
		Decimal<Decimal>;
		Float<Float> DEFAULT(123.5);
		NameRef<DBSName> ALLOW_NULL DEFAULT(NULL);
		MemoryOnly<Integer>
			LABEL("In Memory Integer");
		OtherDecimal<Decimal>
			LABEL("Save Only Decimal");
		NullStr<String> ALLOW_NULL;
	}
	
	aliases {
		/* Indicate that "ANumber" can also be used to reference Decimal, the fields are equivalent 
			TODO: check search/searchAndDelete case */
		ANumber = Decimal;
	}
	
	search twoKeys<BasicTwoKeys> {
		filter Master = @SELF;
		sort Value ASC;
	}
}

search InclBasicTwoKeys<BasicTwoKeys> {
	filter Master = ?;
	sort Value ASC;
}

search ManyField<DBSTest> {
	filter ( ( Bool = ? AND Float = ? ) OR ( Bool = ? AND Decimal = ? ) );
}

search SortSearch<DBSTest> {
	filter Name ~= "Search:*";
	sort Decimal ASC;
}

search KeySortSearch<DBSTest> {
	filter Name ~= "Search:*";
}

search MultiSortSearch<DBSTest> {
	filter Name ~= "Search:*";
	sort Decimal,Name ASC;
}

mapper DBSTest {
	provider DBTest;
	
	fields {
		using basic {
			@ID => ID;
			@Name = Name;
			Date = @Date;
			@Time = Time;
			@DateTime = DateTime;
			@Bool = 	Bool;
			@Decimal = Decimal;
			@Decimal <= OtherDecimal;
			@Float = Float;
			
			/* Link DB value directly to entity field record key */
			@NameRef = NameRef.ID;
			@NullStr = NullStr;
		}
	}
}

/* Used to check that an explicit identifier works*/
entity DBSIdentEx {
	fields {
		ID<Integer> ALT_RECORD_KEY IDENTIFIER;
		Name<String> ALT_RECORD_KEY;
		Value<Decimal>;
	}
}

mapper DBSIdentEx {
	provider DBTest;
	fields {
		using basic {
			@ID => ID;
			@Name = Name;
			@Decimal = Value;
		}
	}
}

entity DBSTwoKeys {
	fields {
		Num<Integer> RECORD_KEY;
		Name<String> RECORD_KEY MAXLEN(20);
		Value<String> MAXLEN(50) DEFAULT("Just 'a' 	Default");
	}
}

mapper DBSTwoKeys {
	provider DBTest;
	fields {
		using twokeys {
			@KeyNum = Num;
			@KeyString = Name;
			@Value = Value;
		}
	}
}

entity DBSStrings {
	class DerivedStrings;
	
	fields  {
		/* If a field is a RECORD_KEY, LOAD_ONLY, and maps to a LAST_INSERT_ID db field, then for creating
			this entity it need not be specified. This is to support auto_increment like columns as the only key for
			an entity. (em: I'm not so happy about this, it should have some kind of DEFAULT(@SAVE) marked! */
		MyID<Integer> RECORD_KEY;
		Labels<Array<String>>;
		Class<String> MAXLEN(2);
		Category<String> MAXLEN(2);
	}
}

mapper DBSStrings {
	provider DBTest;
	fields {
		using convert {
			@Index => convert_id<CustomID>( MyID );
			
			/* Use a custom conversion funtion to convert from/to a comma separated string to/from an array */
			convert_labels<Array<String>>( @Labels ) = Labels;
			@LabelCount <= count_labels<Integer>( Labels );
			
			/* The below simply lacks a unifying concept of how this would work with relation to searching,
				loading, and saving. It may be beyond what Persephone is currently trying to do, so it won't
				be implemented now.*/
			/*@Code = concat_code<String>( Class, Category );*/
		}
	}
}

search MyDBSStrings<DBSStrings> {
	filter MyID = ?;
}

entity DBSName {
	fields {
		/* This time we explicitly set IDs */
		ID<Integer> RECORD_KEY;
		
		/* Titles are used for Forms and Listings as the primary way to refer to this entity */
		Name<String> TITLE;
	}
}

mapper DBSName {
	provider DBTest2;
	fields {
		using names {
			@ID = ID;
			@Name = Name;
		}
	}
}

entity DBSLink {
	fields {
		ID<Integer> RECORD_KEY;
		Basic<DBSTest>;
	}
}

mapper DBSLink {
	provider DBTest;
	fields {
		using link {
			@ID => ID;
			@BasicID = Basic.ID;
		}
	}
}

listing SampleList {
	entity DBSTest;
	
	fields {
		/* Custom formatters can be specified for any column */
		_fmt_id( ID ) "Some ID";
		Name; /*Use default label*/
		Decimal "Decimal Value";	
		/*NameRef "Links To"; TODO: support without need for converter */
				
		/* Here the entity itself is provided to the formatter */
		_fmt_ruleaction( @SELF ) "Action";
	}
}

entity BrokenKey {
	fields {
		ID<Integer> RECORD_KEY;
		Name<String>;	/*Unique in DB*/
	}
}

mapper BrokenKey {
	provider DBTest;
	fields {
		using basic {
			@ID => ID;
			@Name = Name;
		}
	}
}

entity NullKey {
	fields {
		ID<Integer> ALT_RECORD_KEY;
		Name<String> ALT_RECORD_KEY ALLOW_NULL;	/*Unique in DB*/
		Decimal<Decimal>;
	}
}

mapper NullKey {
	provider DBTest;
	fields {
		using basic {
			@ID => ID;
			@Name = Name;
			@Decimal = Decimal;
		}
	}
}

entity NullKey2 {
	fields {
		ID<Integer> ALT_RECORD_KEY;
		/* See the NOTE on getKeyBlock in DBSchemaPHP to understand why this is such
			a special case -- the above in NullKey also is, but as there is no default it isn't
			considered under normal circumstances anyways.  This covers a rather special
			use case -- but a nonetheless valid one. */
		Name<String> ALT_RECORD_KEY ALLOW_NULL DEFAULT(NULL);	/*Unique in DB*/
		Decimal<Decimal>;
	}
}

mapper NullKey2 {
	provider DBTest;
	fields {
		using basic {
			@ID => ID;
			@Name = Name;
			@Decimal = Decimal;
		}
	}
}


entity DBSLinkNames {
	fields {
		Left<DBSName> RECORD_KEY;
		Right<DBSName> RECORD_KEY;
		Value<Integer>;
	}
}

mapper DBSLinkNames {
	provider DBTest;
	fields {
		using link2 {
			@NameA = Left.ID;
			@NameB = Right.ID;
			@Value = Value;
		}
	}
}

/**
 * Used to test a traditional 1 to many relationship (a container)
 */
entity BasicTwoKeys {
	fields {
		Master<DBSTest>;
		Value<String>;
	}
}

mapper BasicTwoKeys {
	provider DBTest;
	fields {
		using twokeys {
			@KeyNum = Master.ID;
			@Value = Value;
		}
	}
}

